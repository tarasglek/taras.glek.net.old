
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>All About Performance</title>
  <meta name="author" content="Taras Glek">

  
  <meta name="description" content="I have not blogged recently because I have been busy working on a rather fancy new mode for Dehydra. Turned out it is indeed possible to use &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://taras.glek.net/blog/page/21/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="All About Performance" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" title="subscribe via RSS">All RSS</a></li>
  
  <li><a href="/mozilla.xml" title="subscribe via RSS">Mozilla RSS</a></li>
</ul>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

<script>
if (!window.requestAnimationFrame) {
  window.requestAnimationFrame = window.mozRequestAnimationFrame
    || window.webkitRequestAnimationFrame
    || window.msRequestAnimationFrame;

  window.cancelAnimationFrame = window.mozCancelAnimationFrame
    || window.webkitCancelAnimationFrame
    || window.msCancelAnimationFrame;

}

window._refreshLog = []
function refreshLogCounter() {
  window._refreshLog.push(Date.now())
  window._refreshLogCounter = requestAnimationFrame(refreshLogCounter);
}

window._refreshLogCounter = requestAnimationFrame(refreshLogCounter);
</script>

</nav>
  <header role="banner"><hgroup>
  <h1><a href="/">All About Performance</a></h1>
  
    <h2>and other stuff by Taras Glek</h2>
  
</hgroup>

</header>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2008/03/03/random-news-in-the-dehydra-corner/">Random News in the Dehydra Corner</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-03-03T10:05:31-08:00" pubdate data-updated="true">Mar 3<span>rd</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>I have not blogged recently because I have been busy working on a rather fancy new mode for <a href="http://wiki.mozilla.org/Dehydra_GCC">Dehydra</a>. Turned out it is indeed possible to use JavaScript to walk and generate code to automagically convert thousands of recursive C structures into corresponding JS Objects. Now dehydra will have two modes: a simple pattern matcher that is easy to get started with and a hardcore mode for compiler geeks capable of advanced analyses. More on this later, for now subscribe to <a href="https://lists.mozilla.org/listinfo/dev-static-analysis">static analysis</a> mailing list for more information.</p>

<p>Turns out that I&#8217;m not the first person to <a href="https://sourceforge.net/forum/forum.php?thread_id=1685933&amp;forum_id=624529">embed</a> SpiderMonkey into GCC.</p>

<p>I have gotten in touch with two different GCC plugin projects. Seems that other projects are more academic in nature and still in the early design/development stages.</p>

<p>In constrast, Dehydra efforts are driven by existing unmet needs. In two months we went from having a crazy idea about using GCC for static analysis to having Benjamin <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=419622">integrate</a> support for Dehydra checks into the moz 2 development repository to be run in a tinderbox.</p>

<p>I am also excited to see that people are discovering that Dehydra can be used to explore the codebase. We are not quite at the stage where one can interactively query the codebase from an ajax UI, but we are making <a href="http://blog.mozilla.org/dmandelin/2008/02/14/dtrace-c-mysteries-solved/">steps</a> in the right direction. As part of this trend, dehydra documentation is starting to migrate to MDC.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2008/02/06/gcc4-elsa-together-at-last/">GCC4 + Elsa, Together at Last?</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-02-06T05:26:44-08:00" pubdate data-updated="true">Feb 6<span>th</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>David Mandelin has been going through <a href="http://wiki.mozilla.org/Pork">Pork</a> fixing bugs and now it is almost working with GCC4. Prior to Dave&#8217;s involvement people would run into Elsa&#8217;s scary template bugs and switch back to GCC3.4 while trembling with fear. I asked Dave to fix a few easily work-aroundable (in Moz, not in Elsa) crashes in Elsa caused by Mozilla source and he did. Recently, I accidentally ran Elsa on a Mozilla .ii file produced by GCC4 and magically it processed! Turns out that the 3-4 bugs that Dave fixed also fixed 90% of the failures caused by GCC4 headers. The good news is that soon people won&#8217;t have to worry about that pesky GCC3.4 dependancy and run rewriting tools easier.</p>

<p><a href="http://wiki.mozilla.org/Dehydra_GCC"><strong>GCC Dehydra</strong></a></p>

<p>I feel like I&#8217;m nearing the feature-complete milestone. I plan to have Dehydra generate conversion code from GCC tree structures to JavaScript objects so we&#8217;ll be able to easily hook into any GCC middle-end pass in pure JS.  Dynamic, GCed, introspective nature of JavaScript should allow for very rapid development of code police/extraction/grep tools. This should result in a consistent codebase for Mozilla 2.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2008/01/25/dehydra-progress/">Dehydra Progress</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-01-25T09:39:30-08:00" pubdate data-updated="true">Jan 25<span>th</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://wiki.mozilla.org/Dehydra_GCC">GCC Dehydra</a> is evolving much faster than the Elsa version did and it is easier to use. Once I implemented virtual methods correctly, Joshua was able to <a href="http://quetzalcoatal.blogspot.com/2008/01/more-fun-and-games.html">do his thing</a> in no time at all. All it takes is a custom GCC (I&#8217;d love to see it packaged) and specifying plugin parameters in CXXFLAGS.</p>

<p>Dehydra has some new tricks now like a tree representation of types (instead of a string) with full typedef support. Lisp remnants in GCC are getting a new life as JavaScript objects.</p>

<p>I&#8217;m current working on exposing the full GCC tree structure in JavaScript so one could do any analysis they wanted in pure JS. Dynamically typed GCC tree nodes are great for that. I&#8217;m starting with middle-end GIMPLE representation so in theory one will be able to analyze anything gcc can compile (Java, C++, C, ObjC, ObjC++, FORTRAN?). Eventually this will be expanded to support frontend specific tree nodes to be able to look at code closer to the way it was written. Oh and I expect people will be able to script large parts of C++ -> JavaScript rewrites with Dehydra.</p>

<p>In theory, one could make tree node conversion two way which would enable writing optimization passes in JS, but that would be silly.</p>

<p><strong>What&#8217;s the point?</strong></p>

<p>I want to be able to do <a href="http://wiki.mozilla.org/Exceptions">Exception-safety analysis</a> in pure JS. I want to enable <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=265084">unit checking </a>(thought typedefs and inline conversion functions) in pure JS.</p>

<p>Additionally, Dehydra should be awesome for generating bindings. For example, I&#8217;ll be able use Dehydra to import GCC&#8217;s autogenerated enums to get string names for nodes.</p>

<p>Also it will become easy to extract callgraphs and various other stats out of the code if they are accessible in JS. Eventually we&#8217;ll be switching Dehydra to Tamarin to do all of the above really really fast.</p>

<p><strong>GCC Plugins</strong></p>

<p>While I am messing with the GCC AST, Dave is working on utilizing GCC&#8217;s <a href="http://blog.mozilla.org/dmandelin/">control flow graphs</a> with a separate plugin. Eventually we&#8217;ll merge our work, but for now it&#8217;s nice to not step on each others toes while adding features to the compiler. Given how easy life is with plugins I am amazed that people chose to go uphill bothways and not collaborate on a plugin interface for their crazy GCC extensions. Yes, I&#8217;m looking at you: <a href="http://mygcc.free.fr/">mygcc</a> and <a href="http://www.gccxml.org/HTML/Index.html">gccxml</a>.</p>

<p>Aren&#8217;t there <a href="http://www.eclipse.org/cdt/">IDEs</a> interested in making use of GCC internals too or is everybody interested in maintaining <a href="http://git.kernel.org/?p=devel/sparse/sparse.git;a=blob;f=expression.c;h=289927ac7c88eb5bffbbb450915a7b829394d5a0;hb=a02aeb329d5a8f9047c0b75b7e7f64ee2db3ffcf">yet another crappy C parser</a> like Linux&#8217;s Sparse tool?</p>

<p>I&#8217;m looking forward to exploring the many ways we can reuse what&#8217;s in the compiler to empower developers for Mozilla 2.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2008/01/17/gcc-spidermonkey-gcc-dehydra/">GCC + SpiderMonkey = GCC Dehydra</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-01-17T08:16:07-08:00" pubdate data-updated="true">Jan 17<span>th</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><strong>Analysis</strong></p>

<p><a href="http://wiki.mozilla.org/Dehydra_GCC">GCC Dehydra</a> is starting to work. I encourage people try it out for their code scanning needs. The main missing feature is control-flow-sensitive traversal, which means that currently function bodies are traversed represented in a sequential fashion. It is the most complicated part of <a href="http://wiki.mozilla.org/DeHydra">Dehydra</a>, but most of the time this feature is not needed.</p>

<p>So far I got Benjamin&#8217;s <a href="http://hg.mozilla.org/users/bsmedberg_mozilla.com/xpcomgc-patches/?file/de1d37e87cf4/find-stack-comptrs.js">stack-nsCOMPtr finding script</a> to do stuff, which indicates that most of the features are working.</p>

<p>My vision is to switch to the GCC backend for all of our code analysis needs since it is well tested, fairly feature complete works with new versions of GCC (by definition).</p>

<p>Not everything is perfect in GCC land. There are some frustrating typedef issues to <a href="http://gcc.gnu.org/ml/gcc/2008-01/msg00280.html">solve</a>.</p>

<p><strong>Source Re-factoring</strong></p>

<p>Elsa still holds its own when it comes to refactoring code because it has a much cleaner lexer/parser and rarely opts to &#8220;optimize away&#8221; original AST structure. We should stick with Elsa&#8217;s arcane requirement of having to preprocess files with gcc &lt;= 3.4 until either GCC becomes viable as a platform for refactoring or <a href="http://clang.llvm.org/">clang</a> matures.</p>

<p>GCC is not suitable for refactoring work because it:</p>

<ol>
<li>Starts simplifying the AST  too early</li>
<li>The parser is handwritten and therefore would be hard to modify to maintain end-of-AST-node location info.</li>
<li>GCC reuses many AST nodes which means their locations point at the declaration rather than usage-point.</li>
<li>Handwritten nature of GCC makes any of these above improvements time-consuming to implement and the political issues are something I&#8217;d rather not deal with.
Most of these wouldn&#8217;t have been an issue if GCC was written in <a href="http://en.wikipedia.org/wiki/ML_programming_language">ML</a> :) <strong>What&#8217;s Next?</strong></li>
</ol>


<p>Time to start using GCC Dehydra to enforce GC-safety and lots of fun exception-rewrite preparation work.</p>

<p>Stay tuned for more exciting developments regarding regaining control over source code here and on <a href="http://blog.mozilla.org/dmandelin/2008/01/15/hello-world/">Dave Mandelin&#8217;s blog</a>.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2008/01/08/dehydra-as-a-gcc-plugin/">Dehydra as a GCC Plugin</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-01-08T04:56:48-08:00" pubdate data-updated="true">Jan 8<span>th</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Thanks to the 2-fold increase in manpower working on pork, we finally have an opportunity to work on the nice-to-have things.</p>

<p><strong>Progress</strong></p>

<p>Recently I have been working on a GCC plugin to do Mozilla-specific analyses with GCC.</p>

<p>Unfortunately, I didn&#8217;t notice that GCC had a<a href="http://gcc.gnu.org/svn.html"> plugin branch </a>so I reinvented the wheel there. Fortunately that part was rather easy and turned out that the plugin branch isn&#8217;t very useful to work with as it is in SVN, doesn&#8217;t link GCC with -rdynamic nor does it install the hooks I need in the C++ frontend. Overall the plugin shim is relatively trivial and it will be pretty easy to merge with other similar efforts.</p>

<p>My first and only plugin is a C reimplementation of Dehydra. GCC sources are currently fairly hostile to C++, so I elected to not make my head spin by mixing in C++ in addition to C and JavaScript. I think the C Dehydra has reached the hello world state, to take it for a spin see the <a href="http://wiki.mozilla.org/Dehydra_GCC">wiki page</a>.</p>

<p><strong>GCC Thoughts</strong></p>

<p>Integrating with GCC is pretty awesome. So far I regret not jumping in earlier. I was reluctant to do so as everyone I&#8217;ve talked to (other than <a href="http://tromey.com/blog/">Tom Tromey</a>) claimed that GCC is ridiculously complicated and impossible to do stuff with. In fact academic people are so scared of GCC that they tend to opt to go with commercial frontends that have ridiculus licensing terms and make it impossible to release their work to general public.</p>

<p>GCC internals are pretty crazy since everything is done with macros and the AST is dynamically typed so it&#8217;s fairly painful to figure out seemingly simple things like &#8220;what AST nodes does this AST node contain&#8221;. Additionally, GCC loves rewriting AST nodes inplace as the compilation progresses which sucks when one wants to analyze the AST while it looks as close as possible to the source. GCC parser also sucks to work with as it is implemented as a C code hodge-podge (technical term which applies to much code in GCC). Luckily, I am mainly concerned with poking at data that&#8217;s already in GCC.</p>

<p>The upside is that GCC is a well-tested production compiler that most source compiles with. Integrating with GCC means that the AST is correct (Elsa is a frontend so there is no way of knowing if AST has mistakes in it) . Integration also means that the user doesn&#8217;t have to worry about making preprocessed files and maintain obsolete versions of GCC or old GCC headers. Unlike Elsa, GCC already has useful features like typedef tracking and doesn&#8217;t implement location tracking with a stupid programming trick. Additionally, I hope to reuse computations from from middle-end GCC passes to build my control flow graph, do value numbering and other useful, but tricky to implement stuff.</p>

<p>GCC isn&#8217;t scary at all, it&#8217;s just another way of implementing a compiler. Some people elect to have more pain in life by electing to <a href="http://www.cs.berkeley.edu/~smcpeak/cpp/cplusplus.html">reinvent ML in C++</a> instead of using ML for compiler writing,  others get their pain dosage from working on a C compiler originally generated from LISP sources.</p>

<p>Lastly, I&#8217;d like to thank patient gcc hackers in #gcc without whom I wouldn&#8217;t stand a chance in figuring out how to get this far.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2007/12/28/recent-progress/">Recent Progress</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2007-12-28T05:39:45-08:00" pubdate data-updated="true">Dec 28<span>th</span>, 2007</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Looks like <a href="http://wiki.mozilla.org/Pork">pork</a> is slowly going to get merged back into oink. This makes me happy as it will result in decreased merging headaches and gives more visibility to my work outside of Mozilla. My elkhound changes are already in!</p>

<p>Recently I added support for retaining gnu attributes to elsa and corresponding features dehydra and garburator. Now dehydra can verify things based on attributes and  garburator gained a way to rewrite special cases like classes that are always <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=409088">allocated on the stack</a>. Elsa still drops most attributes, but at least classes, methods and variable declarations are covered.</p>

<p>I also spent a couple of days investigating gcc plugins. Turns out modifying gcc to support plugins is dead easy, but getting anything useful done in GCC requires a steep learning curve. I tried to find how to enumerate all of the toplevel declarations in the source, but I couldn&#8217;t find the correct global variable that corresponds to the toplevel scope(aka the Translation Unit?). I have a few more ideas of what to try next. Once I do that, it shouldn&#8217;t take much work to make a basic gcc-hosted version of dehydra. There is also a gcc plugin branch hosted in the gcc svn, but I can&#8217;t find any example code for it. It isn&#8217;t a big deal since none of the plugins I&#8217;ve seen mentioned venture outside of intra-function analyses.</p>

<p>I am still pondering on how to tackle rewriting Mozilla to use exceptions. It is the key to improving overall readability/perf of Moz C++, but the logistics of writing the corresponding analyses+rewrites followed by a parallel manual correction step are still making my head spin. All I&#8217;m sure about is that the first step to exceptions would be to enable the OOM exceptions and do the corresponding exception safe analysis+rewrite.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2007/12/19/exceptions/">Exceptions</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2007-12-19T07:26:30-08:00" pubdate data-updated="true">Dec 19<span>th</span>, 2007</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Often there are two ways to write code. One way is to design an API and have code patterns adhere to how the API is supposed to be used. Another way is to rely on language features to accomplish the same thing. Typically API-pattern approaches are chosen because compilers are too immature or just don&#8217;t provide the necessary features. Sometimes compilers do catch up and the possibility of utilizing newer language features appears.</p>

<p>In the case of the exception rewrite the task is to rewrite code from a pattern-based (compiler in your head) approach to a more strict C++ construct-based exception paradigm. Unfortunately APIs don&#8217;t enforce their usage as much as a compiler (in part because we don&#8217;t have <a href="http://taras.glek.net/blog/2007/11/29/gcc-plugins-under-my-xmas-tree/">app-spefic compiler plugins</a>) so transforming that into a strict compiler-friendly form automatically isn&#8217;t always realistic (<a href="http://lxr.mozilla.org/seamonkey/source/xpcom/glue/nsIInterfaceRequestorUtils.cpp#43">example</a>). See my previous post for more examples.</p>

<p>Having done more work on the exception conversion I believe that it is possible to switch Mozilla to exceptions to the point of getting it to compile. Unfortunately, I don&#8217;t think that it&#8217;s possible to do this in the Mozilla2 timeframe due to the large amount of manual labour required.</p>

<p>Due to various use cases that don&#8217;t fit the exception model there is a need for an nsresult-lint tool to detect funny (see above) nsresult patterns so code can be manually fixed to enable thrower to transform code correctly.</p>

<p>I expect conversion to exceptions to consist of the following large steps:</p>

<p>XPCOMGC -> nsresult-lint -> thrower automatic conversion -> nsexception-lint -> outparamdel</p>

<ol>
<li>XPCOMGC needs to land first to simplify memory management. Otherwise there will be a lot more nsCOMPtr&lt;>s already_AddRefed&lt;>s and friends.</li>
<li>nsresult-lint would flag code for clean up to assist with the multitude of special cases in the code preventing it from transformation</li>
<li>thrower needs to do some reasonably sophisticated static analysis (sensitive to control flow) to ensure that code is rewritten correctly. The analysis step isn&#8217;t ridiculously hard, but it is considerably more complex than what is done in existing tools.</li>
<li>nsexception-lint tool will flag exception-unsafe code. I expect this to highlight a fair amount of code that needs to be converted to RAII. It will take more manual labour to fix flagged code here than in than step2.</li>
<li>Once exceptions are used the return value is freed up for outparamdel to utilize. This will be a nice optimization and code clean up.
I think the best bet with exceptions would be to start working on them during the moz2 development cycle to have them land early in post-moz2.</li>
</ol>


<p>Or as an alternative we could try to do just the OOM exceptions which are less frequent which would look like:</p>

<p>XPCOMGC -> thrower automatic conversion(OOM cases are easier) -> nsexception-lint</p>

<p>In this case the only significant piece of work is nsexception-lint which would be needed later for a full-blown exception rewrite. It wouldn&#8217;t be so bad to convert code to RAII even before that is required for the full exception rewrite.</p>

<p>For now I&#8217;m going let thrower rest in the pork hg repository while I try to make a <a href="http://wiki.mozilla.org/XPCOMGC/Static_Checker">static checker plugin</a> for gcc. Feel free to ask for clarification. I&#8217;m dealing with after-effects of insomnia so this may not be completely clear.</p>

<p><strong>Update</strong>: Reasonable <a href="http://www.hackcraft.net/raii/">description of RAII</a>.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2007/12/11/switching-to-exceptions-makes-head-spin/">Switching to Exceptions: Makes Head Spin</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2007-12-11T04:10:19-08:00" pubdate data-updated="true">Dec 11<span>th</span>, 2007</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><strong>Typical</strong></p>

<p>It seems that there are 3 stages to doing a rewrite in Moz:</p>

<ol>
<li>Start a new tool. Make sure that it can rewrite some trivial testcases. Add lots of asserts for cases you are unsure about.</li>
<li>Run tool on Mozilla and fix crashes caused by above asserts. Get 80% of the code rewriting correctly.</li>
<li>Get the other 20% rewriting. This often involves major overhauls to rewriting logic due to patterns that weren&#8217;t expected when the spec was written
Usually stage 3 is a few times harder than 2. For garburator rewriting got really hard in stage 3. 90% of my time ended up being spent in stage 3 due to fun issues like figuring out what to do with <a href="http://benjamin.smedbergs.us/blog/2007-11-08/perils-in-rewriting/">unforeseen</a>(in spec) combination of references and nsCOMPtr&lt;>s.</li>
</ol>


<p><strong>Exceptions</strong></p>

<p>With exceptions step 2 is already getting hard. So far I&#8217;ve had to extend elsa to support pattern matching,  and reworked the code patcher to support recursive rewriting.</p>

<p>Now looks like I&#8217;ll need to do some flow-sensitive analysis to rewrite cases like <a href="http://lxr.mozilla.org/seamonkey/source/xpcom/base/nsMemoryImpl.cpp#217">nsMemoryImpl::FlushMemory</a>. I&#8217;m not sure if it is possible to automatically deal with functions like <a href="http://lxr.mozilla.org/seamonkey/source/xpcom/base/nsExceptionService.cpp#290">nsExceptionService::DoGetExceptionFromProvider</a>.</p>

<p>Also, I&#8217;m not yet rewriting code to be bugfree, just trying to get it to compile. Once exceptioned code compiles, step two will be to statically check code to verify that it is exception-safe and convert it to RAII or something.</p>

<p>Here is an <a href="http://people.mozilla.org/~tglek/xpcom.diff">current patch</a> for xpcom/ produced by thrower. At the moment there are still a lot of pattern matches to be added. It mostly handles rv = foo(); if (NS_FAILED(rv)) and a few other simple <a href="http://hg.mozilla.org/oink/?file/fbbcc3e9056b/thrower_tests/">cases</a>.</p>

<p>This is exciting stuff, but really hard, so if anyone has exciting problem solving ideas feel free to ping me.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2007/12/05/exceptional-circumstances/">Exceptional Circumstances</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2007-12-05T06:23:38-08:00" pubdate data-updated="true">Dec 5<span>th</span>, 2007</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>My previous post on outparam rewriting <a href="http://taras.glek.net/blog/2007/11/28/volume-of-refactoring-ahead/">described</a> the wealth of functions that can be rewritten. Unfortunately, most functions in Mozilla are declared in XPIDL interfaces.</p>

<p>I have been convinced that my plan to rewrite xpidlgen to avoid outparameters wont be possible because most XPIDLinterfaces can be implemented by JavaScript in a few different ways. That is problematic because in addition to return values, JavaScript can also have an exception thrown at any point and have that converted to an nsresult error code by XPConnect. That means that the getters implemented in JavaScript are not in the set of functions that only return NS_OK+outparam/someerror. I wouldn&#8217;t be at all disappointed if someone proved me wrong here.</p>

<p><strong>nsexception</strong></p>

<p>There is one other way to rid the code of outparameters (including getter_AddRefs and friends). Time to face my greatest reluctance: rewriting Mozilla to use exceptions. Brendan has been talking about it for a long time, but I have been skeptical until now, mostly due to the complexity of rewriting that much code. However, I have more confidence in rewriting huge amounts of code now since the XPCOMGC rewrite which touched most functions in Mozilla without too much trouble (in relative terms).</p>

<p><strong>Motivation</strong></p>

<p>There are some obvious benefits to be gained from switching to exceptions other than a reduction in code-size (and footprint?) and having code that looks more like common C++.</p>

<p>We would like to modify tamarin to use C++ exceptions such that an exception thrown from JavaScript would unroll the mixed C++/JS stack. This would simplify and enable significant optimizations for XPConnect.</p>

<p>I am dreaming of JITed marshaling code for C++->JS calls and having a low level FFI interface(ie being able to call most C/C++ methods <a href="http://starkravingfinkle.org/blog/2007/09/hello-js-ctypes-goodbye-binary-components/">directly</a>) on the JavaScript side such that tracing JIT could automatically optimize common XPConnect calls. This an exciting area and there are lots of details to be worked out, so I&#8217;d love to see some feedback (or better yet proof of concept code!) on this.</p>

<p><strong>The Plan</strong> - Rewriting</p>

<p>I have started implementing thrower (I am not a great namer), a tool for converting various code patterns involving nsresult into something that uses an nsexception wrapper.</p>

<p>Since this rewrite requires a lot more scanning for code patterns I added an elsa feature to allow pattern matching on AST nodes in C++ (also using exceptions). Since there are lot of patterns to transform, for documentation I will be writing many minimal testcases documenting(and testing) exactly what gets rewritten. Any interested parties are welcome to contribute Mozilla error handling patterns as testcases.</p>

<p><strong>Verifying the Result </strong></p>

<p>Just like in the XPCOMGC rewrite, code will have to be scanned to verify that it fits in the &#8220;new world order&#8221;. Unlike XPCOMGC, there are additional flow-sensitive issues to scan for to ensure that the code is thread-safe. The scans are at a lower level than dehydra currently works at, so it&#8217;s a perfect opportunity to either extend dehydra or write the new tool.</p>

<p>It would be especially cool to implement the code analysis tool as a <a href="http://taras.glek.net/blog/2007/11/29/gcc-plugins-under-my-xmas-tree/">gcc plugin</a>.  Sean Callanan&#8217;s &#8220;Extending GCC with Modular GIMPLE Optimizations&#8221; paper in the <a href="http://ols2006.108.redhat.com/2007/GCC-Reprints/GCC2007-Proceedings.pdf">GCC summit proceedings</a> should be an excellent starting point.</p>

<p>This is an exciting experiment. I look forward to reducing speculation on the risks/benefits of switching the codebase to use exceptions with some concrete data.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2007/11/29/gcc-plugins-under-my-xmas-tree/">GCC Plugins Under My Xmas Tree?</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2007-11-29T13:59:41-08:00" pubdate data-updated="true">Nov 29<span>th</span>, 2007</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Over at LWN there is an article on <a href="http://lwn.net/Articles/258700/">GCC plugins</a>. It touches onto how it would be useful to implement static analysis tools as GCC plugins.</p>

<p>It does not mention that certain optimizations are not feasible without interfacing with the compiler and that there could be a very significant decrease in errors if we the compiler were pluggable with API-specific checks. Wouldn&#8217;t it be nice if less developer time had to be spent hunting for common bugs and more implementing awesome new features?</p>

<p>Typically safety is accomplished by executing code in a Virtual Machine that does extra runtime checks with Just In Time compilation to make up for performance losses. This approach has many known performance and footprint disadvantages. It is used by languages like Java and Scheme.</p>

<p>Applications in these languages are slow and/or ship with a JIT compiler to optimize them during their runtime. C++ is compiled ahead of run time and has a reputation for running faster than these dynamic languages. However it also makes it a lot easier to make mistakes such as leak memory and buffer overflows. One can use the C++ OO system to perform extra-runtime checks to avoid some of these issues but that tends to cancel out any performance advantages of writing code in C++.</p>

<p>Another approach is to enforce various safety-related properties through the compiler. Awesome existing languages such as <a href="http://en.wikipedia.org/wiki/OCaml">OCaml</a> come with a strict type system that ensures that once code compiles it will run fast and have a lower bug percentages than comparable code in other languages. EcmaScript4 will feature a rocking type system similar to OCaml.</p>

<p>C++ does not have such an awesome typesystem. However, there are many C++ errors that occur frequently and should be detected by the compiler, however long as there is no way to specify Mozilla-specific type system restrictions the compiler has no way of getting that information. Such plugins provide a certain piece of mind that once code complies with whatever rules we set for it, it is more likely to run correctly. Furthermore, some optimizations that we have in mind for Mozilla 2 (such as incremental garbage collection) will be much easier to work with if the compiler flags memory misuse at compile time.</p>

<p>Currently we can use dehydra to scan the codebase, but it would be much more efficient to be able to plug such verification abilities into every developer&#8217;s GCC. I sincerely hope that whoever is in charge of the plugin decision at GCC will realize the massive advantage this would give to GCC over other compilers.</p>

<p>ps. Another use for plugins is to enable more aggressive optimizations. Small changes in the sourcecode can affect how conservative the generated code this. A clever plugin could warn whenever gcc cancels an optimization due to misbehaving source.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/22/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/20/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2012/12/24/making-pages-load-faster/">Making pages load faster</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/12/21/interesting-bugzilla-activity/">Snappy #45: The view from home</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/12/17/hello-octopress/">Hello Octopress</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/11/26/coping-with-flash-hangs/">Coping with Flash hangs</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/11/16/snappy-44-fixing-tab-switching-in-vancouver/">Snappy #44: Fixing tab switching in Vancouver</a>
      </li>
    
  </ul>
</section>


<section>
  <h1>Latest Tweets</h1>
  <ul id="tweets">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  <script type="text/javascript">
    $.domReady(function(){
      getTwitterFeed("tarasglek", 4, false);
    });
  </script>
  <script src="/javascripts/twitter.js" type="text/javascript"> </script>
  
    <a href="http://twitter.com/tarasglek" class="twitter-follow-button" data-show-count="false">Follow @tarasglek</a>
  
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p><h6>
  Copyright &copy; 2013 - Taras Glek - content on this site is licensed under the
Creative Commons Attribution Share-Alike License v3.0 or any later version.

  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span></h6>
</p>
<script>
//indicate that content has been loaded
window._monitorContentLoaded = Date.now()
</script>
<script src="http://monitor-taras-glek-net.appspot.com/static/monitor.js">
</script>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'allaboutperformance-tarasglek';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
