
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>All About Performance</title>
  <meta name="author" content="Taras Glek">

  
  <meta name="description" content="Squash Milestone Reached Squash can now produce a patch that squashes my testcase class nsCSSLoaderImpl into the nsICSSLoader interface such that the &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://taras.glek.net/blog/page/24/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="All About Performance" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">All RSS</a></li>
  
  <li><a href="/blog/categories/mozilla/atom.xml" rel="subscribe-rss" title="subscribe via RSS">Mozilla RSS</a></li>
</ul>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <header role="banner"><hgroup>
  <h1><a href="/">All About Performance</a></h1>
  
    <h2>and other stuff by Taras Glek</h2>
  
</hgroup>

</header>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2007/01/03/squashed-and-compiled/">Squashed and Compiled</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2007-01-03T03:22:25-08:00" pubdate data-updated="true">Jan 3<span>rd</span>, 2007</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><strong>Squash Milestone Reached</strong> Squash can now produce a patch that squashes my testcase class nsCSSLoaderImpl into the nsICSSLoader interface such that the resulting code compiles, links and runs!</p>

<p><strong>Gory Details</strong> Patching function bodies turned out easier than expected. Since the last post, I&#8217;ve added the ability to rewrite variable declarations, casts and static method calls. This was enough to get nsCSSLoader.cpp compiling.</p>

<p>I also ran into an issue where some methods need to remain virtual such that they can be referenced from other modules. I added a -sq-virtual flag to specify method names which need to stay virtual.</p>

<p>I discovered that the implementation class can be used from other source files so now squash can work on multiple files. Unfortunately, this made me run into another Elsa misfeature: memory allocation. Elsa data structures do not attempt to clean up in their destructors. Once an AST is produced, it will remain in memory for the duration of execution. This is an issue, because merely parsing all of the .i files in layout/style/ takes over 600M of memory even though squash is strictly sequential and processes a single file at a time. Hopefully, converting Elsa to use auto_ptr is feasible and I wont have to resort to funny fork() tricks to reclaim memory.</p>

<p><strong>ML vs C++ for Compilers: Rant</strong> I wonder why people insist on using C++ for symbolic manipulations instead of an *ml like O&#8217;Caml and either give up or, more frequently, reinvent features such as the ml type system, list processing, garbage collection or pattern matching. Isn&#8217;t it more productive to not have to deal with segfaults, slow compilation times and have a tenfold reduction in code size?</p>

<p><strong>Squash Usage</strong> First I grep the build directory for usage of CSSLoaderImpl. This imprecise and will eventually be handled by squash itself, but first the memory deallocation issue has to be addressed or an index of the whole sourcetree needs to be built.</p>

<p>find -name *.o | xargs grep CSSLoaderImpl</p>

<p>This returned nsCSSLoader.o and nsLayoutStatics.o . Now .i files are produced by running make in their respective directories</p>

<p>make nsCSSLoader.i make nsLayoutStatics.i</p>

<p>For convenience I gather the .i files in a moz directory and run squash.</p>

<p>./squash -o-lang GNU_Cplusplus -sq-exclude-include string/nsTString.h -sq-include nsString.h -sq-include nsCOMArray.h -sq-virtual LoadSheetSync -sq-virtual LoadSheet -sq-implementation CSSLoaderImpl moz/nsCSSLoader.i moz/nsLayoutStatics.i > cssloader.patch</p>

<p>Turns out pretty printing C++ is hard and Oink/Elsa&#8217;s pretty printer still needs a lot of work. By producing patches and only rewriting part of the code squash rewrites only the code that needs changing. This avoids pretty printer bugs, and maximally preserves comments and the original code structure. The wackyness of the pretty printed code is apparent in the <a href="http://glek.net:8080/~taras/cssloader.patch">cssloader.patch</a>, especially in the function bodies.</p>

<p><strong>Future Work</strong> I am happy to see that patching is viable even without precise source coordinates or preprocessor support in Elsa. My near term goals for squash are:</p>

<ul>
<li>Push squash upstream</li>
<li>Add the ability to translate out-parameters to return values where possible</li>
<li>Get a list of candidates for DeCOMtamination and improve squash enough to process all of them</li>
<li>Work on a source code indexer. This would be useful to both squash as a semantic grep database and could be used to improve lxr.
In the longer term, I would also like to see some Elsa changes:</li>
<li>Figure out a memory de-allocation strategy</li>
<li>Resolve the pain that is caused by Elsa having own &#8220;string&#8221; class which makes using STL an exercise in namespace verbosity. If Elsa were to switch to C++ strings, the above de-allocation job would be simplified too.</li>
<li>Elsa is lossy when it comes to C++ extensions: may need to extend the Elsa AST a little</li>
<li>It would be nice to improve Elsa memory consumption further. This would be hard.</li>
<li>It would be great to make Elsa&#8217;s C++ <a href="http://www.parashift.com/c++-faq-lite/const-correctness.html">const-correct</a></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2006/12/21/oink-meet-squash/">Oink, Meet Squash</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2006-12-21T07:55:25-08:00" pubdate data-updated="true">Dec 21<span>st</span>, 2006</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Progress</p>

<p>I spent some time proving to myself that it is possible to automate DeCOMtamination. The result is squash - a tool that aims to accomplish the first step of DeCOMtamination. My near term goals are to be able to squash together a real life XPCOM interface and implementation such that:</p>

<ol>
<li>The resulting code compiles</li>
<li>Firefox runs correctly</li>
<li>Simple functions using out parameters are converted to use return values instead
Currently I am approximately halfway through with first requirement. In its current form squash lives as a patch to the <a href="http://www.cubewano.org/oink">oink suite</a> of tools.</li>
</ol>


<p>Usage</p>

<ul>
<li>Pick a simple XPCOM implementation class to squash. I like</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CSSLoaderImpl</span></code></pre></td></tr></table></div></figure>


<p>.
  * Produce a .i file because Oink/Elsa do not have an integrated preprocessor yet.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> make CXX="gcc -E" nsCSSLoader.o; mv nsCSSLoader.o nsCSSLoader.i</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Squash it:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>./squash -o-lang GNU_Cplusplus -sq-implementation CSSLoaderImpl  nsCSSLoader.i  -sq-exclude-include string/nsTString.h -sq-include "nsString.h" &gt; /tmp/cssloader.patch &gt; cssloader.patch</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Apply the patch:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>patch -p0 &lt; cssloader.patch</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Run make, deduce the problem with the patch and start over
Current functionality at the header level:</li>
<li>Class member merging

<ul>
<li>virtual interface members are replaced with non-virtual ones from implementation</li>
<li>Class members and their parameters are renamed: eg s/CSSLoaderImpl/nsICSSLoader/</li>
</ul>
</li>
<li>Additional members from the implementation are added to the interface</li>
<li>Extra class/struct definitions used by the implementation members are moved up into the header as needed</li>
<li>Header and forward declaration inference

<ul>
<li>The resulting class will usually not compile because more headers are needed. Squash computes the set difference of class definitions as used by the implementation and the interface. Part of the list ends up as forwad declarations, the other part is translated futher into #include statements.</li>
<li>The above is trickly algorithm to fully implement fully, so in the meantime there are also manual overrides with -sq-include and -sq-exclude-include
At the source level squash renames the class part of function definitions along with their arguments.</li>
</ul>
</li>
</ul>


<p><strong>Results</strong></p>

<p><a href="http://glek.net:8080/~taras/cssloader.patch.gz">Sample patch output</a>.</p>

<p><a href="http://glek.net:8080/~taras/oink.patch.gz">Oink patch</a>.</p>

<p><strong>Challenges and Limitations</strong></p>

<p>I am really grateful for Elsa&#8217;s ability to parse C++ as used in Mozilla. I think this opens a lot of doors to automation, optimizations and new features that would be too laborious to even consider implementing otherwise. However Elsa still has some maturing to do. We loose typedef information, pretty-printing is still spotty and looks too different from parsed C++, but the biggest challenge is the lack of an &#8220;end-of-ASTNode&#8221; position information. All these will be addressed in the future, but in the meantime I have to make unfortunate choices of either getting distracted and working on Elsa/Oink internals or do work-around and continue with writing tools. My short term goal is to finish step 1 and to get squash into the oink SVN.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2006/12/05/static-analysis/">Static Analysis</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2006-12-05T01:50:38-08:00" pubdate data-updated="true">Dec 5<span>th</span>, 2006</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><strong>Introduction</strong></p>

<p>My name is Taras Glek. I have been tasked with working on static analysis tools to automate <a href="http://wiki.mozilla.org/Gecko:DeCOMtamination">deCOMtamination</a>, verify code, etc.</p>

<p><strong>Progress</strong></p>

<p>C++ is a hard language to parse and no static analysis can be done before Mozilla source code be represented as an abstract syntax tree. My first step was to get the Mozilla trunk parsing with <a href="http://www.cs.berkeley.edu/~smcpeak/elkhound/">Elsa</a>. With a small fix, Elsa now parses all files needed to build Firefox with -DNS_DISABLE_LITERAL_TEMPLATE (Elsa&#8217;s template support is incomplete).</p>

<p>Now that code parses we can move to the next step of writing tools that can analyze the Mozilla AST. These would prove certain parts of code correct or do source-to-source transformations such as the planned <a href="http://weblogs.mozillazine.org/roadmap/archives/2006/11/oinkbased_patch_generation.html">patch tool</a>. More applications of static analysis <a href="http://wiki.mozilla.org/Static_Analysis">here</a>. DeCOMtamination of the Gecko core is a time consuming task and is the main candidate for static analysis. I started formalizing the broad tasks collectively referred to as DeCOMtamination into an <a href="http://wiki.mozilla.org/Gecko:DeCOMtamination_Algorithm">algorithm</a> that could be implemented. I am prototyping the analysis in O&#8217;Caml using the <a href="http://www.cs.ru.nl/~tews/olmar/">Olmar</a> binding to Elsa. O&#8217;Caml is a great language to this task because it has a lot of <a href="http://flint.cs.yale.edu/cs421/case-for-ml.html">features</a> for writing compilers and it allows me to load and traverse parts of the AST in an interactive console which greatly speeds up development. I am currently able to process class declarations, graph the class hierarchy into a giant pseudo-UML class diagram and am working on an ability to move class members up from the implementation class into the interface class while adding forward declarations, etc.</p>

<p>Additionally I am involved in garbage collection related analysis that prevents unsafe uses of the garbage collection API and improving LXR precision and functionality via feeding it data from Elsa/Olmar.</p>

<p><strong>Update:</strong> This mini-<a href="http://glek.net:8080/~taras/presentation.pdf">presentation</a> should clarify some of the reasons why we are doing deCOMtamination.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/23/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2012/12/17/hello-octopress/">Hello Octopress</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/11/26/coping-with-flash-hangs/">Coping with Flash hangs</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/11/16/snappy-44-fixing-tab-switching-in-vancouver/">Snappy #44: Fixing tab switching in Vancouver</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/11/05/snappy-43-big-improvements-faster-startup-smoother-tabstrip/">Snappy #43: Big improvements: faster startup? Smoother tabstrip!</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/10/26/snappy-42/">Snappy #42</a>
      </li>
    
  </ul>
</section>


<section>
  <h1>Latest Tweets</h1>
  <ul id="tweets">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  <script type="text/javascript">
    $.domReady(function(){
      getTwitterFeed("tarasglek", 4, false);
    });
  </script>
  <script src="/javascripts/twitter.js" type="text/javascript"> </script>
  
    <a href="http://twitter.com/tarasglek" class="twitter-follow-button" data-show-count="false">Follow @tarasglek</a>
  
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p><h6>
  Copyright &copy; 2012 - Taras Glek - content on this site is licensed under the
Creative Commons Attribution Share-Alike License v3.0 or any later version.

  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span></h6>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'allaboutperformance-tarasglek';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
